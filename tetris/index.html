<html><head>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5252039909284209"
     crossorigin="anonymous"></script>
  <base href="/" />
<style>
  body {
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
    font-family: Arial, sans-serif;
    color: white;
  }

  .game-container {
    width: 500px;  /* Changed from 600px */
    text-align: center;
  }

  #game {
    border: 2px solid #333;
    background: rgba(0, 0, 0, 0.8);
  }

  .info {
    margin: 20px 0;
    display: flex;
    justify-content: space-between;
  }

  .controls {
    margin-top: 20px;
    font-size: 0.9em;
    color: #888;
  }

  .difficulty-select {
    background: rgba(0, 0, 0, 0.8);
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 20px;
    width: 100%; /* Added to ensure it uses full container width */
  }

  .game-title {
    font-size: 4em;
    font-weight: bold;
    margin-bottom: 30px;
    text-transform: uppercase;
    letter-spacing: 5px;
    text-shadow: 2px 2px 8px rgba(255, 255, 255, 0.3);
    background: linear-gradient(45deg, #FF0D72, #0DC2FF, #0DFF72, #F538FF, #FF8E0D, #FFE138, #3877FF);
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: titleGlow 2s ease-in-out infinite alternate;
  }

  @keyframes titleGlow {
    from {
      filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.4));
    }
    to {
      filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));
    }
  }

  .difficulty-select button {
    margin: 5px;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.3s;
  }

  .difficulty-select button:hover {
    transform: scale(1.1);
  }

  .difficulty-info {
    margin-top: 15px;
    font-size: 0.9em;
    color: #aaa;
    text-align: left;
    padding: 10px 20px; /* Changed from 10px 30px to reduce horizontal padding */
    border-top: 1px solid #333;
  }

  .difficulty-info ul {
    list-style-type: none;
    padding: 0;
  }

  .difficulty-info li {
    margin: 5px 0;
    padding-left: 20px;
    position: relative;
  }

  .difficulty-info li::before {
    content: "•";
    position: absolute;
    left: 5px;
  }

  #veryeasy { background: #8BC34A; color: white; }
  #easy { background: #4CAF50; color: white; }
  #normal { background: #2196F3; color: white; }
  #hard { background: #f44336; color: white; }
  #extreme { background: #9C27B0; color: white; }

  .hidden {
    display: none;
  }

  .custom-settings {
    margin-top: 15px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 5px;
    text-align: left;
  }

  .custom-setting {
    margin: 10px 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .custom-setting input {
    width: 100px;
    padding: 5px;
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid #555;
    border-radius: 3px;
    color: white;
  }

  #applyCustom {
    margin-top: 10px;
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s;
    background: #607D8B;
    color: white;
  }

  #applyCustom:hover {
    transform: scale(1.05);
  }

  .background-pieces {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    overflow: hidden;
  }

  .tetris-piece {
    position: absolute;
    opacity: 0.1;
    animation: float linear infinite;
  }

  @keyframes float {
    from {
      transform: translateY(100vh) rotate(0deg);
    }
    to {
      transform: translateY(-100px) rotate(360deg);
    }
  }

  .pause-button {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.8);
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    color: white;
    border: 1px solid #333;
    transition: all 0.3s;
  }

  .pause-button:hover {
    background: rgba(20, 20, 20, 0.9);
    transform: scale(1.05);
  }

  .pause-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  .pause-message {
    background: rgba(0, 0, 0, 0.9);
    padding: 20px;
    border-radius: 10px;
    border: 1px solid #333;
    text-align: center;
  }

  /* Add this CSS for the game over overlay */
  .game-over-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  .game-over-message {
    background: rgba(0, 0, 0, 0.9);
    padding: 30px;
    border-radius: 10px;
    border: 1px solid #333;
    text-align: center;
    animation: fadeIn 0.3s ease-out;
  }

  @keyframes fadeIn {
    from { opacity: 0; transform: scale(0.9); }
    to { opacity: 1; transform: scale(1); }
  }

  .game-over-message h2 {
    margin: 0 0 20px 0;
    color: #f44336;
  }

  .game-over-message .final-score {
    font-size: 1.2em;
    margin-bottom: 20px;
  }

  .restart-button {
    background: #2196F3;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.3s;
  }

  .restart-button:hover {
    transform: scale(1.1);
    background: #1976D2;
  }

  /* Add this CSS for the credits text */
  .credits {
    position: fixed;
    bottom: 20px;
    left: 20px;
    font-size: 14px;
    color: rgba(255, 255, 255, 0.5);
    font-family: Arial, sans-serif;
    z-index: 10;
  }

  .credits a {
    color: rgba(255, 255, 255, 0.7);
    text-decoration: none;
    transition: color 0.3s;
  }

  .credits a:hover {
    color: rgba(255, 255, 255, 0.9);
  }

  .difficulty-indicator {
    font-size: 0.9em;
    margin-top: 10px;
    text-align: center;
    padding: 5px;
    border-radius: 5px;
    text-transform: uppercase;
    font-weight: bold;
  }

  .difficulty-veryeasy { color: #8BC34A; }
  .difficulty-easy { color: #4CAF50; }
  .difficulty-normal { color: #2196F3; }
  .difficulty-hard { color: #f44336; }
  .difficulty-extreme { color: #9C27B0; }
  .difficulty-custom { color: #607D8B; }

  /* Updated settings-button CSS */
  .settings-button {
    position: fixed;
    top: 20px;
    left: 20px; /* Changed from left: 50% */
    transform: none; /* Remove transformation that was centering the button */
    background: rgba(0, 0, 0, 0.8);
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    color: white;
    border: 1px solid #333;
    transition: all 0.3s;
  }

  .settings-button:hover {
    background: rgba(20, 20, 20, 0.9);
    transform: scale(1.05); /* Remove translateX and just scale on hover */
  }

  .settings-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  .settings-menu {
    background: rgba(0, 0, 0, 0.9);
    padding: 30px;
    border-radius: 10px;
    border: 1px solid #333;
    width: 400px;
    max-width: 90%;
  }

  .settings-menu h2 {
    margin: 0 0 20px 0;
    color: #2196F3;
    text-align: center;
  }

  .settings-section {
    margin-bottom: 20px;
  }

  .settings-section h3 {
    color: #fff;
    margin-bottom: 10px;
    border-bottom: 1px solid #333;
    padding-bottom: 5px;
  }

  .control-setting {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 10px 0;
  }

  .control-button {
    background: #333;
    border: 1px solid #555;
    color: white;
    padding: 5px 10px;
    border-radius: 3px;
    cursor: pointer;
    min-width: 80px;
    text-align: center;
  }

  .control-button:hover {
    background: #444;
  }

  .control-button.listening {
    background: #2196F3;
  }

  .settings-footer {
    display: flex;
    justify-content: flex-end;
    gap: 10px;
    margin-top: 20px;
  }

  .settings-footer button {
    padding: 8px 16px;
    border-radius: 4px;
    border: none;
    cursor: pointer;
    transition: all 0.3s;
  }

  .save-button {
    background: #2196F3;
    color: white;
  }

  .cancel-button {
    background: #666;
    color: white;
  }

  .settings-footer button:hover {
    transform: scale(1.05);
  }

  .warning-message {
    color: #ff4444;
    font-size: 0.9em;
    margin-top: 5px;
    display: none;
  }
</style>
</head>
<body>
<div class="credits">
  Created by <a href="https://mixelstuff.com" target="_blank">Mixel346</a> with <a href="https://websim.ai" target="_blank">Websim.ai</a>
</div>
<button class="pause-button" id="pauseButton">Pause (P)</button>
<button class="settings-button" id="settingsButton">Settings ⚙️</button>
<div class="pause-overlay" id="pauseOverlay">
  <div class="pause-message">
    <h2>Game Paused</h2>
    <p>Press P or click the pause button to resume</p>
  </div>
</div>
<div class="settings-overlay" id="settingsOverlay">
  <div class="settings-menu">
    <h2>Settings</h2>
    <div class="settings-section">
      <h3>Controls</h3>
      <div class="control-setting">
        <span>Move Left:</span>
        <button class="control-button" data-action="moveLeft">A</button>
      </div>
      <div class="control-setting">
        <span>Move Right:</span>
        <button class="control-button" data-action="moveRight">D</button>
      </div>
      <div class="control-setting">
        <span>Soft Drop:</span>
        <button class="control-button" data-action="softDrop">S</button>
      </div>
      <div class="control-setting">
        <span>Hard Drop:</span>
        <button class="control-button" data-action="hardDrop">W</button>
      </div>
      <div class="control-setting">
        <span>Rotate Left:</span>
        <button class="control-button" data-action="rotateLeft">←</button>
      </div>
      <div class="control-setting">
        <span>Rotate Right:</span>
        <button class="control-button" data-action="rotateRight">→</button>
      </div>
    </div>
    <div class="settings-section">
      <h3>Visual Settings</h3>
      <div class="control-setting">
        <span>Show Background Pieces:</span>
        <input type="checkbox" id="settingsBackgroundToggle" checked>
      </div>
    </div>
    <div class="settings-footer">
      <button class="cancel-button" id="cancelSettings">Cancel</button>
      <button class="save-button" id="saveSettings">Save</button>
    </div>
  </div>
</div>
<div class="game-over-overlay" id="gameOverOverlay">
  <div class="game-over-message">
    <h2>Game Over!</h2>
    <div class="final-score">Score: <span id="finalScore">0</span></div>
    <button class="restart-button" id="restartButton">Play Again</button>
  </div>
</div>
<div class="game-container">
  <div id="difficulty-select" class="difficulty-select">
    <h1 class="game-title">Mixel's Tetris</h1>
    <h2>Select Difficulty</h2>
    <button id="veryeasy">Very Easy</button>
    <button id="easy">Easy</button>
    <button id="normal">Normal</button>
    <button id="hard">Hard</button>
    <button id="extreme">Extreme</button>
    <button id="custom" style="background: #607D8B; color: white;">Custom</button>
    <div id="custom-settings" class="custom-settings hidden">
      <div class="custom-setting">
        <label>Starting Speed (ms):</label>
        <input type="number" id="customStartSpeed" value="1000" min="100" max="2000" step="100">
      </div>
      <div class="custom-setting">
        <label>Enable Speed Increase:</label>
        <input type="checkbox" id="customEnableSpeedIncrease" checked>
      </div>
      <div class="custom-setting" id="speedIncreaseContainer">
        <label>Speed Increase per Level (%):</label>
        <input type="number" id="customSpeedIncrease" value="2" min="0" step="0.1">
      </div>
      <div class="warning-message" id="speedWarning">
        WARNING: Speeds over 10% may break the game's calculation
      </div>
      <button id="applyCustom" style="background: #607D8B; color: white;">Apply</button>
    </div>
    <div class="difficulty-info">
      <ul>
        <li><strong style="color: #8BC34A">Very Easy:</strong> Constant speed 1.5s, No speed increase, Score x0.5</li>
        <li><strong style="color: #4CAF50">Easy:</strong> Starting speed 1.2s, 1% faster per level, Score x1</li>
        <li><strong style="color: #2196F3">Normal:</strong> Starting speed 1.0s, 2% faster per level, Score x2</li>
        <li><strong style="color: #f44336">Hard:</strong> Starting speed 0.8s, 3% faster per level, Score x3</li>
        <li><strong style="color: #9C27B0">Extreme:</strong> Starting speed 0.5s, 5% faster per level, Score x5</li>
        <li><strong style="color: #607D8B">Custom:</strong> Set your own starting speed and increase rate, Score x1</li>
      </ul>
    </div>
  </div>
  <canvas id="game" width="300" height="600" class="hidden"></canvas>
  <div id="game-info" class="hidden">
    <div class="info">
      <div>Score: <span id="score">0</span></div>
      <div>Speed: <span id="speed">1000</span>ms</div>
    </div>
    <div class="difficulty-indicator" id="difficultyIndicator"></div>
    <div class="controls">
      A/D to move • W for hard drop • S for soft drop • ←/→ to rotate
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const BLOCK_SIZE = 30;
const BOARD_WIDTH = 10;
const BOARD_HEIGHT = 20;

const SHAPES = [
  [[1, 1, 1, 1]], // I
  [[1, 1], [1, 1]], // O
  [[1, 1, 1], [0, 1, 0]], // T
  [[1, 1, 1], [1, 0, 0]], // L
  [[1, 1, 1], [0, 0, 1]], // J
  [[1, 1, 0], [0, 1, 1]], // S
  [[0, 1, 1], [1, 1, 0]], // Z
];

const COLORS = [
  '#FF0D72',
  '#0DC2FF',
  '#0DFF72',
  '#F538FF',
  '#FF8E0D',
  '#FFE138',
  '#3877FF',
];

const MINI_PIECE_SIZE = 5; // Size of background pieces in pixels

function toggleBackgroundPieces(show) {
  const container = document.querySelector('.background-pieces');
  if (container) {
    container.style.display = show ? 'block' : 'none';
  }
}

function createBackgroundPieces() {
  const container = document.createElement('div');
  container.className = 'background-pieces';
  document.body.prepend(container);

  // Create 50 pieces
  for (let i = 0; i < 50; i++) {
    const piece = document.createElement('div');
    piece.className = 'tetris-piece';
    
    // Random shape
    const shapeIndex = Math.floor(Math.random() * SHAPES.length);
    const shape = SHAPES[shapeIndex];
    
    // Create piece HTML
    let pieceHtml = '<div style="display: grid; grid-gap: 1px;">';
    shape.forEach(row => {
      pieceHtml += '<div style="display: flex;">';
      row.forEach(cell => {
        if (cell) {
          pieceHtml += `<div style="width: ${MINI_PIECE_SIZE}px; height: ${MINI_PIECE_SIZE}px; background: ${COLORS[shapeIndex]}"></div>`;
        } else {
          pieceHtml += `<div style="width: ${MINI_PIECE_SIZE}px; height: ${MINI_PIECE_SIZE}px;"></div>`;
        }
      });
      pieceHtml += '</div>';
    });
    pieceHtml += '</div>';
    piece.innerHTML = pieceHtml;

    // Random position and animation
    piece.style.left = Math.random() * 100 + 'vw';
    piece.style.animationDuration = (Math.random() * 20 + 10) + 's'; // Between 10-30s
    piece.style.animationDelay = (Math.random() * -30) + 's'; // Start at random positions

    container.appendChild(piece);
  }
}

const DEFAULT_CONTROLS = {
  moveLeft: 'a',
  moveRight: 'd',
  softDrop: 's',
  hardDrop: 'w',
  rotateLeft: 'arrowleft',
  rotateRight: 'arrowright'
};

let controls = {...DEFAULT_CONTROLS};

// Load saved controls if they exist
if (localStorage.getItem('tetrisControls')) {
  controls = JSON.parse(localStorage.getItem('tetrisControls'));
}

let board;
let score;
let level;
let levelProgress; // This will now track total lines cleared
let gameOver;
let currentPiece;
let dropCounter;
let lastTime;
let difficulty = 'normal';
let isPaused = false; // Added variable for pause state

const DIFFICULTY_SETTINGS = {
  veryeasy: {
    baseSpeed: 1500,
    speedIncrease: 0  // No speed increase
  },
  easy: {
    baseSpeed: 1200,
    speedIncrease: 0.01  // 1% faster per level
  },
  normal: {
    baseSpeed: 1000,
    speedIncrease: 0.02  // 2% faster per level
  },
  hard: {
    baseSpeed: 800,
    speedIncrease: 0.03  // 3% faster per level
  },
  extreme: {
    baseSpeed: 500,
    speedIncrease: 0.05  // 5% faster per level
  },
  custom: {
    baseSpeed: 1000,
    speedIncrease: 0.02
  }
};

function initGame() {
  board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
  score = 0;
  levelProgress = 0; // This will now track total lines cleared
  gameOver = false;
  currentPiece = new Piece();
  dropCounter = 0;
  lastTime = 0;
  document.getElementById('score').textContent = '0';
  document.getElementById('speed').textContent = DIFFICULTY_SETTINGS[difficulty].baseSpeed;
  requestAnimationFrame(update);
}

function startGame(selectedDifficulty) {
  difficulty = selectedDifficulty;
  document.getElementById('difficulty-select').classList.add('hidden');
  document.getElementById('game').classList.remove('hidden');
  document.getElementById('game-info').classList.remove('hidden');
  
  // Update difficulty indicator
  const difficultyIndicator = document.getElementById('difficultyIndicator');
  difficultyIndicator.textContent = `Difficulty: ${selectedDifficulty.charAt(0).toUpperCase() + selectedDifficulty.slice(1)}`;
  difficultyIndicator.className = `difficulty-indicator difficulty-${selectedDifficulty}`;
  
  initGame();
}

document.addEventListener('DOMContentLoaded', function() {
  createBackgroundPieces();
});

document.getElementById('veryeasy').addEventListener('click', () => startGame('veryeasy'));
document.getElementById('easy').addEventListener('click', () => startGame('easy'));
document.getElementById('normal').addEventListener('click', () => startGame('normal'));
document.getElementById('hard').addEventListener('click', () => startGame('hard'));
document.getElementById('extreme').addEventListener('click', () => startGame('extreme'));

document.getElementById('custom').addEventListener('click', () => {
  const customSettings = document.getElementById('custom-settings');
  customSettings.classList.toggle('hidden');
});

document.getElementById('customEnableSpeedIncrease').addEventListener('change', function(e) {
  const speedIncreaseContainer = document.getElementById('speedIncreaseContainer');
  speedIncreaseContainer.style.display = e.target.checked ? 'flex' : 'none';
});

document.getElementById('customSpeedIncrease').addEventListener('input', function(e) {
  const warningElement = document.getElementById('speedWarning');
  const value = parseFloat(e.target.value);
  
  if (value > 10) {
    warningElement.style.display = 'block';
  } else {
    warningElement.style.display = 'none';
  }
});

document.getElementById('applyCustom').addEventListener('click', () => {
  const startSpeed = parseInt(document.getElementById('customStartSpeed').value);
  const enableSpeedIncrease = document.getElementById('customEnableSpeedIncrease').checked;
  const speedIncrease = enableSpeedIncrease ? 
    parseFloat(document.getElementById('customSpeedIncrease').value) / 100 : 
    0;
  
  // Validate inputs
  if (startSpeed < 100 || startSpeed > 2000) {
    alert('Starting speed must be between 100ms and 2000ms');
    return;
  }
  
  if (enableSpeedIncrease && speedIncrease < 0) {
    alert('Speed increase cannot be negative');
    return;
  }
  
  // Update custom difficulty settings
  DIFFICULTY_SETTINGS.custom = {
    baseSpeed: startSpeed,
    speedIncrease: speedIncrease
  };
  
  // Start game with custom settings
  startGame('custom');
});

class Piece {
  constructor() {
    // Use a bag randomizer system to ensure fair distribution
    if (!this.constructor.bag || this.constructor.bag.length === 0) {
      this.constructor.bag = [...Array(SHAPES.length).keys()];
      // Fisher-Yates shuffle
      for (let i = this.constructor.bag.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [this.constructor.bag[i], this.constructor.bag[j]] = 
        [this.constructor.bag[j], this.constructor.bag[i]];
      }
    }
    
    const shapeIndex = this.constructor.bag.pop();
    this.shape = SHAPES[shapeIndex];
    this.color = COLORS[shapeIndex]; // Match colors to shapes consistently
    this.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(this.shape[0].length / 2);
    this.y = 0;
  }
}

function getGhostPosition() {
  const ghost = {
    shape: currentPiece.shape,
    x: currentPiece.x,
    y: currentPiece.y
  };

  while (!collide(ghost)) {
    ghost.y++;
  }
  ghost.y--;

  return ghost;
}

function collide(piece = currentPiece) {
  for (let y = 0; y < piece.shape.length; y++) {
    for (let x = 0; x < piece.shape[y].length; x++) {
      if (piece.shape[y][x] &&
          (piece.y + y >= BOARD_HEIGHT ||
           piece.x + x < 0 ||
           piece.x + x >= BOARD_WIDTH ||
           (board[y + piece.y] &&
            board[y + piece.y][x + piece.x]) !== 0)) {
        return true;
      }
    }
  }
  return false;
}

function draw() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  const ghost = getGhostPosition();
  ghost.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) {
        ctx.fillStyle = `${currentPiece.color}33`;
        ctx.fillRect(
          (ghost.x + x) * BLOCK_SIZE,
          (ghost.y + y) * BLOCK_SIZE,
          BLOCK_SIZE - 1,
          BLOCK_SIZE - 1
        );
      }
    });
  });

  board.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) {
        ctx.fillStyle = COLORS[value - 1];
        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
      }
    });
  });

  currentPiece.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) {
        ctx.fillStyle = currentPiece.color;
        ctx.fillRect(
          (currentPiece.x + x) * BLOCK_SIZE,
          (currentPiece.y + y) * BLOCK_SIZE,
          BLOCK_SIZE - 1,
          BLOCK_SIZE - 1
        );
      }
    });
  });
}

function merge() {
  currentPiece.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) {
        board[y + currentPiece.y][x + currentPiece.x] = COLORS.indexOf(currentPiece.color) + 1;
      }
    });
  });
}

function rotate(dir) {
  const rotated = currentPiece.shape[0].map((_, i) =>
    dir > 0 
      ? currentPiece.shape.map(row => row[i]).reverse()
      : currentPiece.shape.map(row => row[row.length - 1 - i])
  );
  const prevShape = currentPiece.shape;
  currentPiece.shape = rotated;
  if (collide()) {
    currentPiece.shape = prevShape;
  }
}

function hardDrop() {
  while (!collide()) {
    currentPiece.y++;
  }
  currentPiece.y--;
  merge();
  clearLines();
  currentPiece = new Piece();
  if (collide()) {
    gameOver = true;
    showGameOver();
  }
}

function clearLines() {
  let linesCleared = 0;
  outer: for (let y = board.length - 1; y >= 0; y--) {
    for (let x = 0; x < board[y].length; x++) {
      if (board[y][x] === 0) {
        continue outer;
      }
    }
    const row = board.splice(y, 1)[0].fill(0);
    board.unshift(row);
    y++;
    linesCleared++;
  }
  
  if (linesCleared > 0) {
    // Add difficulty multipliers
    const difficultyMultipliers = {
      veryeasy: 0.5,
      easy: 1,
      normal: 2,
      hard: 3,
      extreme: 5,
      custom: DIFFICULTY_SETTINGS.custom.speedIncrease * 100 // Convert decimal to percentage for multiplier
    };
    
    // Calculate score with difficulty multiplier
    const multiplier = difficultyMultipliers[difficulty];
    score += linesCleared * 100 * multiplier;
    
    // Increment levelProgress for each line cleared - this now accumulates continuously
    levelProgress += linesCleared;
    
    document.getElementById('score').textContent = score;
  }
}

function getDropInterval() {
  const settings = DIFFICULTY_SETTINGS[difficulty];
  if (difficulty === 'veryeasy') {
    const speed = settings.baseSpeed;
    document.getElementById('speed').textContent = speed;
    return speed; // No speed increase for very easy
  }
  
  // Calculate new speed with percentage reduction based on total lines cleared (levelProgress)
  // Remove the Math.max limit to allow speeds below 100ms
  const speed = settings.baseSpeed * Math.pow(1 - settings.speedIncrease, levelProgress);
  
  // Update the speed display (round to nearest millisecond)
  document.getElementById('speed').textContent = Math.round(speed);
  
  return speed;
}

function togglePause() {
  if (gameOver) return;
  
  isPaused = !isPaused;
  const pauseButton = document.getElementById('pauseButton');
  const pauseOverlay = document.getElementById('pauseOverlay');
  
  if (isPaused) {
    pauseButton.textContent = 'Resume (P)';
    pauseOverlay.style.display = 'flex';
  } else {
    pauseButton.textContent = 'Pause (P)';
    pauseOverlay.style.display = 'none';
    lastTime = performance.now();
    requestAnimationFrame(update);
  }
}

function showGameOver() {
  const overlay = document.getElementById('gameOverOverlay');
  const finalScore = document.getElementById('finalScore');
  finalScore.textContent = score;
  overlay.style.display = 'flex';
}

function hideGameOver() {
  const overlay = document.getElementById('gameOverOverlay');
  overlay.style.display = 'none';
}

function restartGame() {
  hideGameOver();
  document.getElementById('game').classList.add('hidden');
  document.getElementById('game-info').classList.add('hidden');
  document.getElementById('difficulty-select').classList.remove('hidden');
}

function update(time = 0) {
  if (gameOver || isPaused) return;

  const deltaTime = time - lastTime;
  lastTime = time;
  dropCounter += deltaTime;

  if (dropCounter > getDropInterval()) {
    currentPiece.y++;
    dropCounter = 0;
    if (collide()) {
      currentPiece.y--;
      merge();
      clearLines();
      currentPiece = new Piece();
      if (collide()) {
        gameOver = true;
        showGameOver();
        return;
      }
    }
  }

  draw();
  requestAnimationFrame(update);
}

// Settings menu functionality
let listeningForKey = null;

function openSettings() {
  document.getElementById('settingsOverlay').style.display = 'flex';
  if (!isPaused && !gameOver) {
    togglePause();
  }
  
  // Update control buttons to show current bindings
  Object.entries(controls).forEach(([action, key]) => {
    const button = document.querySelector(`[data-action="${action}"]`);
    if (button) {
      button.textContent = key.toUpperCase();
    }
  });
  
  // Update background toggle
  document.getElementById('settingsBackgroundToggle').checked = 
    document.getElementById('settingsBackgroundToggle').checked;
}

function closeSettings() {
  document.getElementById('settingsOverlay').style.display = 'none';
  listeningForKey = null;
  if (isPaused && !gameOver) {
    togglePause();
  }
}

function saveSettings() {
  // Save controls to localStorage
  localStorage.setItem('tetrisControls', JSON.stringify(controls));
  
  // Update background pieces visibility directly from settings
  const settingsBackgroundToggle = document.getElementById('settingsBackgroundToggle');
  toggleBackgroundPieces(settingsBackgroundToggle.checked);
  
  closeSettings();
}

// Add event listeners for settings buttons
document.getElementById('settingsButton').addEventListener('click', openSettings);
document.getElementById('cancelSettings').addEventListener('click', closeSettings);
document.getElementById('saveSettings').addEventListener('click', saveSettings);

// Handle control button clicks
document.querySelectorAll('.control-button').forEach(button => {
  button.addEventListener('click', () => {
    if (listeningForKey === button) {
      listeningForKey.classList.remove('listening');
      listeningForKey = null;
      return;
    }
    
    if (listeningForKey) {
      listeningForKey.classList.remove('listening');
    }
    
    button.textContent = 'Press a key...';
    button.classList.add('listening');
    listeningForKey = button;
  });
});

// Listen for key presses when setting controls
document.addEventListener('keydown', event => {
  if (listeningForKey) {
    event.preventDefault();
    const action = listeningForKey.dataset.action;
    controls[action] = event.key.toLowerCase();
    listeningForKey.textContent = event.key.toUpperCase();
    listeningForKey.classList.remove('listening');
    listeningForKey = null;
  }
});

// Update the keydown event listener to use the custom controls
document.addEventListener('keydown', event => {
  if (event.key.toLowerCase() === 'p') {
    togglePause();
    return;
  }
  
  if (isPaused || gameOver) return;
  
  const key = event.key.toLowerCase();
  
  switch (key) {
    case controls.moveLeft:
      currentPiece.x--;
      if (collide()) currentPiece.x++;
      break;
    case controls.moveRight:
      currentPiece.x++;
      if (collide()) currentPiece.x--;
      break;
    case controls.softDrop:
      currentPiece.y++;
      if (collide()) {
        currentPiece.y--;
        merge();
        clearLines();
        currentPiece = new Piece();
        if (collide()) {
          gameOver = true;
          showGameOver();
        }
      }
      dropCounter = 0;
      break;
    case controls.hardDrop:
      hardDrop();
      break;
    case controls.rotateLeft:
      rotate(-1);
      break;
    case controls.rotateRight:
      rotate(1);
      break;
  }
});

document.getElementById('pauseButton').addEventListener('click', togglePause);
document.getElementById('restartButton').addEventListener('click', restartGame);
</script>
</body></html>